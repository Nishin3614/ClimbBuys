// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 演出ブロック処理 [stagingblock.cpp]
// Author : fujiwaramasato
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "stagingblock.h"
#include "debugproc.h"

#include "manager.h"
#include "camera.h"
#include "renderer.h"
#include "fade.h"

#include "basemode.h"
#include "opening.h"
#include "openingmanager.h"

#include "3dparticle.h"

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// マクロ定義
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 静的変数宣言
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool CStagingBlock::m_bEnd = false;
int CStagingBlock::m_nFrame = 0;
CStagingBlock::Block_Condition CStagingBlock::m_Condition = {};
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// オーバーローバーコンストラクタ処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStagingBlock::CStagingBlock() : CScene_X::CScene_X()
{
	m_bStopMove = false;
	m_nAngle = 0;
	m_Vector = D3DVECTOR3_ZERO;
	m_BlockType = STAGING_BLOCKTYPE::NORMAL;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デストラクタ処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStagingBlock::~CStagingBlock()
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 初期化処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Init()
{
	// 速さの初期値
	m_fSpeed = 10.0f;
	m_fBurstSpeed = 10.0f;
	// 吹っ飛びベクトルをランダムに設定
	SetBurstVector(CCalculation::RandomDirectionVector(NULL, true));
	// シーンxの初期化
	CScene_X::Init();
	m_Vector.y = -1.0f;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 終了処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Uninit(void)
{
	CScene_X::Uninit();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 更新処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Update(void)
{
	switch (m_BlockType)
	{
	case CStagingBlock::STAGING_BLOCKTYPE::NORMAL:
		break;
	case CStagingBlock::STAGING_BLOCKTYPE::LEVITATION:
		// 空中浮遊処理
		Levitating();
		break;
	case CStagingBlock::STAGING_BLOCKTYPE::ASCENT:
		break;
	case CStagingBlock::STAGING_BLOCKTYPE::DESCENT:
		// 下降処理
		Descent();
		break;
	}

	CScene_X::Update();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 描画処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Draw(void)
{
	CScene_X::Draw();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ベースブロック全ソースの読み込み
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HRESULT CStagingBlock::Load(void)
{
	return S_OK;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 読み込んだ情報を破棄処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::UnLoad(void)
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// メモリの生成
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStagingBlock * CStagingBlock::Create(D3DXVECTOR3 const &pos,
	D3DXVECTOR3 const &rot,
	D3DXVECTOR3 const &size,
	D3DXCOLOR color,
	int const &nModelId,
	bool const &bShadowMap,
	STAGING_BLOCKTYPE type)
{
	// 変数宣言
	CStagingBlock * pStagingBlock = new CStagingBlock;

	// シーン管理設定
	pStagingBlock->ManageSetting(CScene::LAYER_3DOBJECT);

	pStagingBlock->SetPos(pos);
	pStagingBlock->SetRot(rot);
	pStagingBlock->SetSize(size);
	pStagingBlock->SetModelColor(color);
	pStagingBlock->SetModelId(nModelId);
	pStagingBlock->SetShadowMap(bShadowMap);
	pStagingBlock->m_BlockType = type;

	// 初期化処理
	pStagingBlock->Init();

	// 生成したオブジェクトを返す
	return pStagingBlock;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 純粋仮想関数 必要ない関数
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Scene_MyCollision(int const & nObjType, CScene * pScene){}
void CStagingBlock::Scene_OpponentCollision(int const & nObjType, CScene * pScene){}
void CStagingBlock::Scene_NoMyCollision(int const & nObjType, CScene * pScene){}
void CStagingBlock::Scene_NoOpponentCollision(int const & nObjType, CScene * pScene){}
D3DXVECTOR3 * CStagingBlock::Scene_GetPPos(void){return nullptr;}
D3DXVECTOR3 * CStagingBlock::Scene_GetPPosold(void){return nullptr;}
D3DXVECTOR3 * CStagingBlock::Scene_GetPMove(void){return nullptr;}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ブロックの移動
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::BlockFall()
{
	if (!m_bStopMove)
	{
		D3DXVECTOR3 vector = COpeningManager::GetTargetpos(this->m_nBlockNun) - this->GetPos();
		D3DXVec3Normalize(&vector, &vector);

		D3DXVECTOR3 temppos = this->GetPos() + vector * m_fSpeed;

		if (temppos.y <= COpeningManager::GetTargetpos(this->m_nBlockNun).y)
		{
			this->SetPos(COpeningManager::GetTargetpos(this->m_nBlockNun));
		}
		else
		{
			this->SetPos(this->GetPos() + vector * m_fSpeed);
		}
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ブロックの破裂
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::BlockBurst()
{
	if (this->m_nBlockNun == 4)
	{
		m_Vector = CManager::GetRenderer()->GetCamera()->GetPosV() - D3DXVECTOR3(this->GetPos().x, this->GetPos().y + 80, this->GetPos().z);

		if (CCalculation::Range_Absolute(CManager::GetRenderer()->GetCamera()->GetPosV().z, this->GetPos().z) <= 50)
		{
			// タイトルへ遷移
			// フェード状態が何も起こっていない状態なら
			if (CManager::GetFade()->GetFade() == CFade::FADE_NONE)
			{
				CManager::GetFade()->SetFade(CManager::MODE_TITLE);
			}
		}
		else
		{
			D3DXVec3Normalize(&m_Vector, &m_Vector);
			this->SetPos(this->GetPos() + m_Vector * m_fBurstSpeed);
		}
	}
	else
	{
		this->SetPos(this->GetPos() + m_Vector * m_fBurstSpeed);
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 空中浮遊処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Levitating()
{
	float fSpeed = (float)CCalculation::GetRandomRange(10, 30);

	GetPos().y += sinf(m_nAngle++ * D3DX_PI / 50) * (fSpeed *= 0.1f);
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 下降処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Descent()
{
	GetPos().y -= 2.0f;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 条件の設定
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::SetCondition(const int PerFrame, const int FrameBetween, const int ToOnes, STAGING_BLOCKTYPE type)
{
	m_Condition.nPerFrame[static_cast<int>(type)]		= PerFrame;
	m_Condition.nFrameBetween[static_cast<int>(type)]	= FrameBetween;
	m_Condition.nToOnes[static_cast<int>(type)]			= ToOnes;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 一定時間毎に演出ブロックを生成
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::Create_Block(D3DXVECTOR3 Originpos, D3DXVECTOR3 Range, int const & nModelId, STAGING_BLOCKTYPE type)
{
	m_nFrame++;

	if (m_nFrame % m_Condition.nPerFrame[static_cast<int>(type)] == 0 && m_Condition.nFrameBetween[static_cast<int>(type)] > m_nFrame)
	{
		D3DXVECTOR3 CreatePos;
		D3DXVECTOR3 RandomRot;

		RandomRot.x = CCalculation::Random_PI();
		RandomRot.y = CCalculation::Random_PI();
		RandomRot.z = CCalculation::Random_PI();

		// ランダムな座標を求める
		if (Range != NULL)
		{
			CreatePos.x = CCalculation::Random(Originpos.x + Range.x);
			CreatePos.y = Originpos.x;
			CreatePos.z = Originpos.z;
		}
		else
		{
			CreatePos = Originpos;
		}

		// オブジェクトの生成
		CStagingBlock::Create(
			CreatePos,
			RandomRot,
			D3DXVECTOR3(3.0f, 3.0f, 3.0f),
			D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f),
			CScene_X::TYPE_BLOCK_SPRING,
			false,
			type
		);
	}
	else
	{
		return;
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 条件の初期化
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStagingBlock::InitCondition()
{
	for (int nCnt = 0; nCnt < static_cast<int>(STAGING_BLOCKTYPE::MAX); nCnt++)
	{
		m_Condition.nPerFrame[nCnt]		 = NULL;
		m_Condition.nFrameBetween[nCnt]	 = NULL;
		m_Condition.nToOnes[nCnt]		 = NULL;
	}
}
